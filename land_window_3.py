# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'land_window.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QBrush, QPixmap
from PyQt5.QtWidgets import QMainWindow
import time, threading
import multiprocessing
import friend_viewer_2
import friend_viewer_3
import socket
from queue import Queue, Empty
import time, threading
import random


def receive_from_server(id_num, client):
    global friend_state
    global friend_id
    global friend_name
    global friend_ready

    BUF_SIZE = 1024  # 设置缓冲区的大小

    n = id_num

    print("开始服务器对用户id{}的receive_from_server循环".format(n))

    loop_flag = True
    while loop_flag:

        mes_from_client = client.recv(BUF_SIZE)  # 从服务器端接收数据
        mes = mes_from_client.decode('utf-8')
        friend_state = mes

        submark = friend_state.find("_")
        friend_id = friend_state[0:submark]
        friend_name = friend_state[submark + 1:]

        if friend_name != "":
            friend_ready = True

        if mes == "OFFLINE":
            loop_flag = False
            break

    print("用户{}的receive_from_server循环关闭".format(str(n)))


def AI_client_land(id_num, name):
    BUF_SIZE = 1024  # 设置缓冲区的大小

    server_addr = ('192.168.1.101', 7500)  # IP和端口构成表示地址
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 返回新的socket对象
    client.connect(server_addr)  # 连接服务器

    mes_from_server = client.recv(BUF_SIZE)  # 从服务器端接收数据
    mes = mes_from_server.decode('utf-8')
    if mes == "ID_NAME":
        mes = str(id_num) + "_" + name
        mes_to_client = mes.encode('utf-8')
        client.sendall(mes_to_client)  # 发送数据到客户端
        time.sleep(0.01)

    t_new = threading.Thread(target=receive_from_server, args=(id_num, client))
    t_new.start()

    return client


def AI_talk(id_num, client_bw):
    time.sleep(15)

    a = random.randint(5, 10)
    for i in range(a):
        mes = str(random.randint(3, 50))
        mes_to_client = mes.encode('utf-8')
        client_bw.sendall(mes_to_client)  # 发送数据到客户端

        time.sleep(random.uniform(1, 3))

    mes = "说完了，共说了{}句话".format(str(a))
    mes_to_client = mes.encode('utf-8')
    client_bw.sendall(mes_to_client)  # 发送数据到客户端


class Ui_MainWindow(QMainWindow):
    def __init__(self, MainWindow, parent=None):
        super(Ui_MainWindow, self).__init__(parent)
        self.MainWindow = MainWindow
        self.count = 0
        self.window_list = []

    def receive_from_server(self, id_num, client):
        global friend_state
        global friend_id
        global friend_name
        global friend_ready

        BUF_SIZE = 1024  # 设置缓冲区的大小

        n = id_num

        print("开始服务器对用户id{}的receive_from_server循环".format(n))

        loop_flag = True
        while loop_flag:

            mes_from_client = client.recv(BUF_SIZE)  # 从服务器端接收数据
            mes = mes_from_client.decode('utf-8')
            friend_state = mes

            submark = friend_state.find("_")
            friend_id = friend_state[0:submark]
            friend_name = friend_state[submark + 1:]

            if friend_name != "":
                friend_ready = True

            # print(friend_id+"以及"+friend_name);

            if mes == "OFFLINE":
                loop_flag = False
                break

        print("用户{}的receive_from_server循环关闭".format(str(n)))

    def client_land(self, id_num, name):
        BUF_SIZE = 1024  # 设置缓冲区的大小

        server_addr = ('192.168.1.101', 7500)  # IP和端口构成表示地址

        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 返回新的socket对象

        client.connect(server_addr)  # 连接服务器

        mes_from_server = client.recv(BUF_SIZE)  # 从服务器端接收数据
        mes = mes_from_server.decode('utf-8')
        if mes == "ID_NAME":
            mes = str(id_num) + "_" + name
            mes_to_client = mes.encode('utf-8')
            client.sendall(mes_to_client)  # 发送数据到客户端
            time.sleep(0.01)

        t_new = threading.Thread(target=self.receive_from_server, args=(id_num, client))
        t_new.start()

        return client

    def setupUi(self):
        self.MainWindow.setObjectName("MainWindow")
        self.MainWindow.resize(600, 400)

        icon = QtGui.QIcon()
        icon_pic = QPixmap("./window resources/present10.png")
        icon.addPixmap(icon_pic, QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.MainWindow.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(self.MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        palette = QtGui.QPalette()
        bk = QPixmap("./window resources/background2.png")
        bk = bk.scaled(self.MainWindow.width(), self.MainWindow.height())
        palette.setBrush(QtGui.QPalette.Background, QBrush(bk))
        # palette.setBrush(MainWindow.backgroundRole(), QBrush(QPixmap("./window resources/background.png").scaled(MainWindow.size(),QtCore.Qt.IgnoreAspectRatio,QtCore.Qt.SmoothTransformation)))
        self.MainWindow.setPalette(palette)

        self.landButton = QtWidgets.QPushButton(self.centralwidget)
        self.landButton.setGeometry(QtCore.QRect(160, 320, 280, 36))
        self.landButton.clicked.connect(self.callback_of_landbutton)

        self.landButton.setStyleSheet(
            "QPushButton{background:rgb(50,170,220);border-radius:15px;}QPushButton:hover{background:rgb(0,220,255);}")

        font = QtGui.QFont()
        font.setFamily("微软雅黑")
        font.setPointSize(16)
        self.landButton.setFont(font)

        self.landButton.setObjectName("Button_land")
        self.MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi()
        QtCore.QMetaObject.connectSlotsByName(self.MainWindow)

    def retranslateUi(self):
        _translate = QtCore.QCoreApplication.translate
        self.MainWindow.setWindowTitle(_translate("MainWindow", "聊聊--登陆界面"))
        self.landButton.setText(_translate("MainWindow", "登 陆"))

    def callback_of_landbutton(self):
        global friend_ready

        print("点击了登陆按钮！")
        self.count += 1

        id_num = self.count
        name = "小明"
        # client_bw = None
        client_bw = self.client_land(id_num, name)

        while not friend_ready:
            time.sleep(0.1)



        self.friend_window = friend_viewer_3.Friend_Viewer_Window(client_bw, id_num, None)
        self.window_list.append(self.friend_window) #要把临时生成的friend_window实例变量存起来，否则会被覆盖，无法形成超过2个以上的多进程窗口！！！

        self.friend_window.show()

    def AI_talk(self):

        for i in range(50):
            time.sleep(1)
            print(i)

    def show(self):
        self.MainWindow.setWindowFlags(QtCore.Qt.MSWindowsFixedSizeDialogHint)
        self.MainWindow.show()


def main(kind="AI", id_num=0):
    global friend_state
    global friend_id
    global friend_name
    global friend_ready

    friend_ready = False
    friend_state = ""
    friend_name = ""

    friend_list = [0, 1, 4, 8]
    screen_queue = Queue(maxsize=5)

    if kind == "AI":
        name = "游客{}".format(str(id_num))
        client_bw = AI_client_land(id_num, name)
        if id_num != -1:
            t_talk = threading.Thread(target=AI_talk, args=(id_num, client_bw,))
            t_talk.start()
            print("AI开始说话")

    elif kind == "web":
        app = QtWidgets.QApplication(sys.argv)
        ui = Ui_MainWindow(QtWidgets.QMainWindow())
        ui.setupUi()
        ui.show()
        sys.exit(app.exec_())


if __name__ == '__main__':
    main("web")
