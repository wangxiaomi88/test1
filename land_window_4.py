# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'land_window.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QBrush, QPixmap
from PyQt5.QtWidgets import QMainWindow
import multiprocessing
import friend_viewer_3
import socket
# from queue import Queue, Empty
import time, threading
import random
import test_codec_mes
from test_public_resource import *


class Land_Window(QMainWindow):


    # id_list=[]
    # name_list=[]


    def __init__(self, parent=None):
        super().__init__(parent)
        self.count = 0
        self.name_txt = "haha"
        self.id_int=0
        self.window_list = []
        self.portrait_pic = QPixmap("./window_resources/client_portrait/default.png")
        self.is_server_ok = False
        self.server_ip_end=-1
        self.setupUi()
        self.friend_ready = False
        self.online_friends_list = []
        self.friend_window = None
        self.friend_id_list=[]
        self.friend_name_list = []



        # Land_Window.id_list=Public_Resource.ID_sequence[:50]
        # Land_Window.name_list=Public_Resource.Name_sequence[:50]


    def receive_from_server(self, id_num, client):

        BUF_SIZE = 1024  # 设置缓冲区的大小

        # print("开始服务器对用户id{}的receive_from_server循环".format(id_num))

        loop_flag = True
        while loop_flag:

            mes_from_server = client.recv(BUF_SIZE)  # 从服务器端接收数据
            mes = mes_from_server.decode('utf-8')
            print(str(id_num)+"接收"+mes)
            legal, kind, source, target, content = test_codec_mes.decode_mes(mes)

            if legal and kind == "ONLINE":
                self.online_friends_list = content


            elif legal and kind == "IDLEAVE":
                self.online_friends_list = content
                print("因ID下线准备update的列表：{}".format(str(self.online_friends_list)))

                #
                # for temp_window in self.window_list:
                #     temp_window.update_online_friend(self.online_friends_list)



            elif legal and kind == "COMM":

                print(mes)

                for i in range(len(self.window_list)):
                    if self.window_list[i].id_num == target:
                        break

                self.window_list[i].deal_sentence(source, target, content)#根据window_list搜索下标匹配的friend_window





            elif legal and kind == "CHATCLOSE":

                print("聊天窗口关闭")

                for i in range(len(self.window_list)):
                    if self.window_list[i].id_num == source:
                        break

                for j in range(len(self.window_list[i].chat_window_list)):
                    if self.window_list[i].chat_window_list[j].other==target:
                        print("关闭了{}号对{}号的聊天框".format(str(source),str(target)))
                        del self.window_list[i].chat_window_list[j]
                        break




            elif legal and kind == "OFFLINE":


                for k in range(len(self.window_list)):
                    if self.window_list[k].id_num == source:
                        del self.window_list[k]
                        break

                self.online_friends_list.remove(source)

                for temp_window in self.window_list:
                    temp_window.update_online_friend(self.online_friends_list)


                loop_flag=False
                break

        print("用户{}的receive_from_server循环关闭".format(str(id_num)))





    def client_land(self, id_num, name):
        BUF_SIZE = 1024  # 设置缓冲区的大小

        hostname = socket.gethostname()
        sysinfo = socket.gethostbyname_ex(hostname)
        ip_addr = sysinfo[2]
        localhost = ip_addr[0]
        for i in range(-1, -len(localhost), -1):
            print(i)
            if localhost[i] == ".":
                break

        sever_ip_fore = localhost[:i + 1]

        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 返回新的socket对象


        if self.server_ip_end>=0:
            # server_addr = (sever_ip_fore+str(self.server_ip_end), 7500)  # IP和端口构成表示地址
            # client.connect(server_addr)  # 连接服务器
            self.is_server_ok = True
        else:

            self.is_server_ok=False


            for i in range(0,255,1):
                try:
                    server_ip=sever_ip_fore+str(i)
                    server_addr = (server_ip, 7500)  # IP和端口构成表示地址
                    temp_search = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 返回新的socket对象
                    temp_search.settimeout(0.1)
                    temp_search.connect(server_addr)  # 连接服务器

                    print("检查点1")
                    mes_from_server = temp_search.recv(BUF_SIZE)  # 从服务器端接收数据
                    mes = mes_from_server.decode('utf-8')

                    if mes == "IFF_ID_NAME":
                        mes = "temp_search"
                        mes_to_server = mes.encode('utf-8')
                        temp_search.sendall(mes_to_server)  # 发送数据到客户端
                        time.sleep(0.01)

                    self.is_server_ok=True
                    self.server_ip_end=i
                    break

                except socket.timeout:
                    print("{}不是服务器".format(str(i)))
                    temp_search.close()




        if self.is_server_ok:


            server_addr = (sever_ip_fore + str(self.server_ip_end), 7500)  # IP和端口构成表示地址
            client.connect(server_addr)  # 连接服务器

            mes_from_server = client.recv(BUF_SIZE)  # 从服务器端接收数据
            mes = mes_from_server.decode('utf-8')
            if mes == "IFF_ID_NAME":
                mes = str(id_num) + "_" + name
                mes_to_server = mes.encode('utf-8')
                client.sendall(mes_to_server)  # 发送数据到客户端
                time.sleep(0.01)

            mes_from_server = client.recv(BUF_SIZE)  # 从服务器端接收数据
            mes = mes_from_server.decode('utf-8')
            print(mes)
            legal, kind, source, target, content = test_codec_mes.decode_mes(mes)
            if kind == "FRIENDS":
                print(str(source) + "号的好友列表为：" + str(content))
                time.sleep(0.01)

            self.friend_id_list=content
            self.friend_name_list=[]
            for item in self.friend_id_list:
                self.friend_name_list.append(Public_Resource.Name_sequence[item])

            if len(self.friend_name_list)>0:
                self.friend_ready = True

            t_new = threading.Thread(target=self.receive_from_server, args=(id_num, client))
            t_new.start()

        return client



    def setupUi(self):
        self.setObjectName("MainWindow")
        self.resize(600, 400)

        icon = QtGui.QIcon()
        icon_pic = QPixmap("./window_resources/present10.png")
        icon.addPixmap(icon_pic, QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.setWindowIcon(icon)

        self.centralwidget = QtWidgets.QWidget()
        self.centralwidget.setObjectName("centralwidget")

        palette = QtGui.QPalette()
        bk = QPixmap("./window_resources/background_school.png")
        bk = bk.scaled(self.width(), self.height())
        palette.setBrush(QtGui.QPalette.Background, QBrush(bk))
        # palette.setBrush(MainWindow.backgroundRole(), QBrush(QPixmap("./window resources/background.png").scaled(MainWindow.size(),QtCore.Qt.IgnoreAspectRatio,QtCore.Qt.SmoothTransformation)))
        self.setPalette(palette)

        font = QtGui.QFont()
        font.setFamily("微软雅黑")
        font.setPointSize(16)

        self.label_id = QtWidgets.QLabel(self.centralwidget)
        self.label_id.setGeometry(QtCore.QRect(160, 220, 80, 36))
        self.label_id.setText("账户id号：")
        self.label_id.setFont(font)
        self.label_id.setStyleSheet("color:rgb(220,220,220)")

        self.label_name=QtWidgets.QLabel(self.centralwidget)
        self.label_name.setGeometry(QtCore.QRect(160, 270, 80, 36))
        self.label_name.setText("昵 称：")
        self.label_name.setFont(font)
        self.label_name.setStyleSheet("color:rgb(220,220,220)")

        self.label_portrait = QtWidgets.QLabel(self.centralwidget)
        self.label_portrait.setGeometry(QtCore.QRect(240, 80, 120, 120))
        self.label_portrait.setPixmap(self.portrait_pic)
        self.label_portrait.setScaledContents (True)

        palette = QtGui.QPalette()
        palette.setBrush(QtGui.QPalette.Base, QBrush(QtGui.QColor(255, 255, 255, 128)))

        self.lineEdit_id = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_id.setGeometry(QtCore.QRect(250, 220, 120, 36))
        self.lineEdit_id.setText("")
        self.lineEdit_id.setFont(font)
        self.lineEdit_id.setPalette(palette)
        self.lineEdit_id.setFrame(0)
        self.lineEdit_id.setFocusPolicy(QtCore.Qt.ClickFocus)
        self.lineEdit_id.textChanged.connect(self.name_change_by_id)

        self.lineEdit_name=QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_name.setGeometry(QtCore.QRect(250, 270, 120, 36))
        self.lineEdit_name.setText("")
        self.lineEdit_name.setFont(font)
        self.lineEdit_name.setFocusPolicy(QtCore.Qt.ClickFocus)


        self.lineEdit_name.setPalette(palette)
        self.lineEdit_name.setFrame(0)




        self.Button_land = QtWidgets.QPushButton(self.centralwidget)
        self.Button_land.setGeometry(QtCore.QRect(160, 320, 280, 36))
        self.Button_land.setFont(font)

        self.Button_land.setStyleSheet(
            "QPushButton{background:rgb(50,170,220);border-radius:15px;}QPushButton:hover{background:rgb(0,220,255);}")

        self.Button_land.setObjectName("Button_land")

        self.Button_land.clicked.connect(self.callback_of_landbutton)



        self.setCentralWidget(self.centralwidget)

        # QtCore.QMetaObject.connectSlotsByName(self.MainWindow)

        self.setWindowTitle("御坂网络--登陆界面")
        self.Button_land.setText("登 陆")
        self.setWindowFlags(QtCore.Qt.MSWindowsFixedSizeDialogHint)


    def name_change_by_id(self):
        try:
            n=int(self.lineEdit_id.text())
            self.lineEdit_name.setText(Public_Resource.Name_sequence[n])

            self.portrait_pic=Public_Resource.Portrait_sequence[n]
            self.label_portrait.setPixmap(self.portrait_pic)
            self.label_portrait.setScaledContents(True)

        except:
            print("输入id非法")




    def callback_of_landbutton(self):

        print("点击了登陆按钮！")
        self.count += 1

        self.id_int=int(self.lineEdit_id.text())
        self.name_txt=Public_Resource.Name_sequence[self.id_int]

        self.Button_land.setText("登陆中")

        time.sleep(0.5)

        client_bw = self.client_land(self.id_int, self.name_txt)

        if self.is_server_ok:
            self.Button_land.setText("登 陆")
            while not self.friend_ready:
                print("还没ready")
                time.sleep(0.1)


            self.friend_window = friend_viewer_3.Friend_Viewer_Window(client_bw, self.id_int, self.name_txt,self.friend_id_list,self.friend_name_list,self.online_friends_list,None)
            self.window_list.append(self.friend_window)  # 要把临时生成的friend_window实例变量存起来，否则会被覆盖，无法形成超过2个以上的多进程窗口！！！
            self.friend_window.show()

            time.sleep(0.3)
            for temp_window in self.window_list:
                temp_window.update_online_friend(self.online_friends_list)

        else:
            print("未搜索到服务器")
            self.Button_land.setText("重新登陆")





    def AI_talk(self):

        for i in range(50):
            time.sleep(1)
            print(i)







#######################################################################################



if __name__ == '__main__':
    # multiprocessing.freeze_support()
    app = QtWidgets.QApplication(sys.argv)
    pub_res_init()
    Public_Resource.Portrait_sequence_init()

    land_window = Land_Window()
    land_window.show()
    sys.exit(app.exec_())


###################################################################################